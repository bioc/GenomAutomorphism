---
title: "A Short Introduction to Algebraic Taxonomy on Genes Regions"
author: 
    - name: Robersy Sanchez
      affiliation: Department of Biology.
                   Pennsylvania State University, University Park, PA 16802
      email: rus547@psu.edu
date: "`r format(Sys.time(), '%d %B %Y')`"
fontsize: 11pt
fontfamily: "serif"
output:
    BiocStyle::html_document:
        toc: true
        toc_depth: 3
        toc_float: 
                collapsed: false
                smooth_scroll: true
        number_sections: true
        theme: united 
        geometry: margin=0.8in
        highlight: tango
toc_float: true
toc_depth: 3
abstract: |
    A short and simply introduction to Algebraic taxonomy of genomic/genes 
    regions is presented here. Analysis of DNA mutational events on DNA 
    Multiple Sequence Alignment (MSA) by means of automorphisms between 
    pairwise DNA sequences algebraically represented as Abelian finite
    group. Herein, show a simple example on how the package can be applied.
vignette: >
    %\VignetteIndexEntry{Get started-with Methyl-IT}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::knitr}
---
    
<style type="text/css">

.watch-out {
  max-width: 1820px !important;
  margin-left: auto;
  margin-right: auto;
  background-color: white;
  font-weight: bold
  font-size: 100%;
  padding: 2px;
}

pre, code {
  max-width: 1820px !important;
  margin-left: auto;
  margin-right: auto;
  background-color: white;
  font-weight: bold
  font-size: 100px;
  padding: 2px;
}

code {
    font-size: 100%;
    font-family: Consolas,Monaco,"Courier New",monospace;
    border-radius: 0;
}

code.r{
  font-size: 100%;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
    class.source = "watch-out",
    collapse = TRUE,
    comment = "#>"
)
```


```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

# Overview
This is a R package to compute the autimorphisms between pairwise aligned DNA
sequences represented as elements from a Genomic Abelian group as described in
reference ([1](#1)). In a general scenario, whole chromosomes or genomic regions
from a population (from any species or close related species) can be
algebraically represented as a direct sum of cyclic groups or more specifically
Abelian *p*-groups. Basically, we propose the representation of multiple
sequence alignments (MSA) of length _N_ as a finite Abelian group created by the
direct sum of Abelian group of _prime-power order_:


$$
\qquad G = (\mathbb{Z}_{p^{\alpha_{1}}_1})^{n_1} \oplus (\mathbb{Z}_{p^{\alpha_{2}}_1})^{n_2} \oplus \dots \oplus (\mathbb{Z}_{p^{\alpha_{k}}_k})^{n_k} 
$$

Where, the $p_i$'s are prime numbers, $\alpha_i \in \mathbb{N}$ and 
$\mathbb{Z}_{p^{\alpha_{i}}_i}$ is the group of integer modulo 
$p^{\alpha_{i}}_i$. 

For the purpose of estimating the automorphism between two aligned DNA
sequences, $p^{\alpha_{i}}_i \in \{5, 2^6, 5^3 \}$.

## Automorphisms

Herein, automorphisms are considered algebraic descriptions of mutational event
observed in codon sequences represented on different Abelian groups. In
particular, as described in references ([3-4](#3)), for each representation of
the codon set on a defined Abelian group there are 24 possible isomorphic
Abelian groups. These Abelian groups can be labeled based on the DNA base-order
used to generate them. The set of 24 Abelian groups can be described as a group
isomorphic to the symmetric group of degree four ($S_4$, see reference
([4](#4))).

For further support about the symmetric group on the 24 Abelian group of 
genetic-code cubes, users can also see [Symmetric Group of the Genetic-Code Cubes.](https://github.com/genomaths/GenomeAlgebra_SymmetricGroup), 
specifically the Mathematica notebook 
_IntroductionToZ5GeneticCodeVectorSpace.nb_ and interact with it using
Wolfram Player, freely available (for Windows and Linux OS) at,
<https://www.wolfram.com/player/>.


# Automorphisms on $\mathbb{Z}_{64}$

First, we proceed to load the R package required for our analysis
```{r library, message=FALSE}
library(GenomAutomorphism)
library(Biostrings)
library(party)
library(partykit)
library(data.table)
library(ggplot2)
library(ggparty)
library(dplyr)
library(CHAID)

```

[CHAID](install.packages("CHAID", repos="http://R-Forge.R-project.org")) 
can be download at: 
 <install.packages("CHAID", repos="http://R-Forge.R-project.org")>

Next, we proceed to check the DNA multiple sequence alignment (MSA) file. This
is a FASTA file carrying the MSA of primate BRCA1 DNA repair gene. Notice that
we are familiar with the _FASTA_ file, then it is better to directly read it
with function automorphism. However, for the current example, this step can be
bypassed, since the MSA is provided provided together with _*GenomAutomorphism*_
R package

```{r fasta, message=FALSE, eval = FALSE}
## Do not run it. This is included with package
URL <- paste0("https://github.com/genomaths/seqalignments/raw/master/BRCA1/",
              "brca1_primates_dna_repair_20_sequences.fasta")

brca1_aln <- readDNAMultipleAlignment(filepath = URL)
```

Load MSA available in the package
```{r dat}
data("brca1_aln", package = "GenomAutomorphism")
brca1_aln
```

The sequence names
```{r names}
strtrim(names(brca1_aln@unmasked), 100)
```

Next, function automorphism will be applied to represent the codon sequence in
the Abelian group $\mathbb{Z}_{64}$ (i.e., the set of integers remainder modulo
64). The codon coordinates are requested on the cube ACGT. Following reference
([4](#4))), cubes are labeled based on the order of DNA bases used to define the
sum operation.

In Z64, automorphisms are described as functions $f(x) = k\,x \quad mod\,64$,
where $k$ and $x$ are elements from the set of integers modulo 64. Below, in
function _automorphism_ three important arguments are given values: _group =
"Z64"_, _cube = c("ACGT", "TGCA")_, and _cube_alt = c("CATG", "GTAC")_. Setting
for group specifies on which group the automorphisms will be computed. These
groups can be: "Z5", "Z64", "Z125", and "Z5^3".

In groups "Z64" and "Z125" not all the mutational events can be described as
automorphisms from a given cube. So, a character string denoting pairs of "dual"
the genetic-code cubes, as given in references ([1-4](#2))), is given as
argument for _cube_. That is, the base pairs from the given cubes must be
complementary each other. Such a cube pair are call dual cubes and, as shown in
reference ([4](#4))), each pair integrates group. If automorphisms are not found
in first set of dual cubes, then the algorithm search for automorphism in a
alternative set of dual cubes.


```{r url, message=FALSE, eval = FALSE}
## Do not run it. This is included with package

nams <- c("human_1","human_2","gorilla_1","gorilla_2","gorilla_3",
        "chimpanzee_1","chimpanzee_2","chimpanzee_3","chimpanzee_4",
        "bonobos_1","bonobos_2","bonobos_3","bonobos_4","silvery_gibbon_1",
        "silvery_gibbon_1","silvery_gibbon_3","golden_monkey_1",
        "golden_monkey_2","gelada_baboon","bolivian_monkey")

brca1_autm <- automorphism(
                      seqs = brca1_aln, 
                      group = "Z64", 
                      cube = c("ACGT", "TGCA"),
                      cube_alt = c("CATG", "GTAC"),
                      nms = nams)
```


Object *brca1_autm* is included with package and can be load typing:
```{r brca1_autm}
data(brca1_autm, package = "GenomAutomorphism")
brca1_autm
```

## Grouping automorphism by automorphism's coefficients
Automorphisms with the same automorphism's coefficients can be grouped. This
task can be accomplished with function automorphismByCoef. However, for the sake
of time, its output is included in the package

```{r autby, eval = FALSE}
## Not need to run it here
autby_coef <- automorphismByCoef(brca1_autm)
```

Object *brca1_autm* is included with package and can be load typing:
```{r brca1_autm}
data(autby_coef, package = "GenomAutomorphism")
autby_coef
```


## Bar plot automorphism distribution by cubes
The automorphism distribution by cubes can be summarized in the bar-plot graphic.

Object *autby_coef* carried all the pairwise comparisons, while it will be
enough to use data from a single spieces as reference, e.g., humans.

First the data must be reordered into a \code{\link[base]{data.frame}} object:
```{r dat}
hautby_coef <- autby_coef[ grep("human", names(autby_coef)) ]
h_autby_coef <- unlist(hautby_coef)
h_autby_coef <- h_autby_coef[ which(h_autby_coef$autm != 1) ]
```



```{r rm-h}
nams <- names(h_autby_coef)
nams <- sub("human[_][1-2][.]", "", nams)
nams <- sub("[_][1-6]", "", nams)

dt <- data.frame(h_autby_coef, species = nams)
dt <- dt[, c("start", "autm", "species", "cube")]
```


Nominal variables are transformed into \code{\link[base]{factor}}
```{r as.factor}
dt$start <- as.numeric(dt$start)
dt$autm <- as.numeric(dt$autm)
dt$cube <- as.factor(dt$cube)
dt$species <- as.factor(dt$species)
```


```{r barplot, fig.height = 5, fig.width = 7}
counts <- table(dt$cube)

par(family = "serif", cex = 0.8, font = 2, mar=c(4,6,4,4))
barplot(counts, #main="Automorphism distribution",
        xlab="Genetic-code cube representation",
        ylab="Fixed mutational events",
        col=c("darkblue","red", "darkgreen", "magenta", "orange"), 
        border = NA, axes = F, #ylim = c(0, 6000),
        cex.lab = 2, cex.main = 1.5, cex.names = 2)
axis(2, at = c(0, 200, 400, 600, 800, 1000), cex.axis = 1.5)
mtext(side = 1,line = -2.5, at = c(0.7, 1.9, 3.1, 4.3, 5.5),
      text = paste0( counts ), cex = 2,
      col = c("white","red", "yellow", "black"))

```


## Conditional Inference Trees with *party* & *partykit* R packages
 
Recursive partitioning of the grouped automorphism data can be accomplished with
function [ctree](https://rdrr.io/cran/party/man/ctree.html) from the R package
[party](https://rdrr.io/cran/party/).


Next, we accomplish the Conditional Inference Tree analysis
```{r ctree}
set.seed(1455)
control <- partykit::ctree_control(testtype = "MonteCarlo",
                         splittest = TRUE, alpha = 0.00027)

tree <- partykit::ctree(species ~., data = dt, minsplit = 200,
                        teststat = "quadratic",
                        control = control,
              splitflavour = "exhaustive")
```


Updating decision tree information: 
```{r util-info}
pvals <- unlist(nodeapply(tree, ids = nodeids(tree), function(n) info_node(n)$p.value))
pvals <- pvals[ pvals < 0.05 ]

## Counts of event per species on each node
node.freq <- sapply(seq_along(tree), function(id) {
                    y <- data_party(tree[id])
                    y <- y[[ "(response)" ]]
                    table(y)
            })
## total counts on each
node.size =  colSums(node.freq)
```


Plotting the tree with [ggparty](https://rdrr.io/cran/ggparty/man/ggparty.html)
```{r ggparty, fig.height = 20, fig.width = 12}
ggparty(tree) +
        geom_edge() +
        geom_edge_label() +
        geom_node_label(line_list = list(aes(label = splitvar),
                aes(label = paste0("N=", node.size, ", p", 
                                ifelse(pvals < .001, "<.001",
                                       paste0("=", round(pvals, 3)))), 
                                             size = 8)),
                        line_gpar = list(list(size = 8), 
                                         list(size = 8)), 
                        ids = "inner") +
        geom_node_info() +
        geom_node_label(aes(label = paste0("N = ", nodesize)),
                        ids = "terminal", nudge_y = -0.0, nudge_x = 0.01) +
        geom_node_plot(gglist = list(
                geom_bar(aes(x = "", fill = species), size = 0.2, width = 0.9,
                         position = position_fill(), color = "black"),
                theme_minimal(base_family = "arial"),
                scale_fill_manual(values = c("gray50","gray55","gray60",
                                             "gray70","gray80","gray85",
                                             "blue","gray95")),
                xlab(""), 
                ylab("Probability"), 
                geom_text(aes(x = "", group = species, 
                              label = stat(count)),
                          stat = "count", position = position_fill(), 
                          vjust = 1.)),
                shared_axis_labels = TRUE, size = 1.25)
```


## Classification Tree Chi-squared Automated Interaction Detection (CHAID)

The current CHAID implementation only accepts nominal or ordinal categorical
predictors. When predictors are continuous, they have to be transformed into
ordinal predictors before using the following algorithm. We create a ordinal 
variable *autms* from variable *autm*. [CHAID](install.packages("CHAID", repos="http://R-Forge.R-project.org")) can be download at: <install.packages("CHAID", repos="http://R-Forge.R-project.org")>



```{r datos}
datos = dt
datos$autms <- case_when(datos$autm < 16 ~ 'XAZ',
                  between(datos$autm, 16, 31) ~ 'XCZ',
                  between(datos$autm, 32, 47) ~ 'XGZ',
                  datos$autm > 47 ~ 'XTZ')
datos$autms <- as.factor(datos$autms)

datos$regions <- case_when(datos$start < 230 ~ 'r_0',
                  between(datos$start, 230, 270) ~ 'r_1',
                  between(datos$start, 271, 305) ~ 'r_2',
                  between(datos$start, 306, 338) ~ 'r_3',
                  between(datos$start, 339, 533) ~ 'r_4',
                  between(datos$start, 534, 570) ~ 'r_5',
                  between(datos$start, 571, 653) ~ 'r_6',
                  between(datos$start, 654, 709) ~ 'r_7',
                  datos$start > 709 ~ 'r_8')

datos$regions <- as.factor(datos$regions)

datos$autm <- as.factor(datos$autm)
datos$species <- as.factor(datos$species)
datos$start <- as.factor(datos$start)
datos$cube <- as.factor(datos$cube)
datos <- datos[, c( "regions","autms", "cube", "species")]
datos
```

Fitting a classification tree with CHAID algorithm
```{r chaid}
ctrl <- chaid_control(minsplit = 160, minprob = 0.20, alpha2 = 0.01, alpha4 = 0.01)
chaid_res <- chaid(species ~ regions + autms + cube , data = datos,
                   control = ctrl)
```



```{r ch, fig.height = 10, fig.width = 14}
plot(chaid_res, margins = c(8, 0, 0, 0),
     terminal_panel = partykit::node_barplot(chaid_res, beside = F, id = F),
    tp_args = list(rot = 50, just = c("right", "top")),
    tnex = 1)

```



Next, the data must be prepared for plotting the tree with 
[ggparty](https://rdrr.io/cran/ggparty/man/ggparty.html):
```{r, plot-data}
##  Updating CHAID decision tree
dp <- data_party(chaid_res)[, c("(fitted)", "(response)")]

chaid_tree <- party(node = node_party(chaid_res), data = datos,
                    fitted = dp, names = names(chaid_res))

## Extract p-values
pvals <- unlist(nodeapply(chaid_tree, ids = nodeids(chaid_tree), function(n) {
    pvals <- info_node(n)$adjpvals
    pvals < pvals[ which.min(pvals) ]
    return(pvals)
}))
pvals <- pvals[ pvals < 0.05 ]

## Counts of event per spciees on each node
node.freq <- sapply(seq_along(chaid_tree), function(id) {
    y <- data_party(chaid_tree, id = id)
    y <- y[[ "(response)" ]]
    table(y)
})
## total counts on each
node.size =  colSums(node.freq)
```



Plotting the tree with [ggparty](https://rdrr.io/cran/ggparty/man/ggparty.html)
```{r chaid-tree, fig.height = 10, fig.width = 14}
ggparty(chaid_tree) +
    geom_edge(aes(color = id, size = node.size[id]/300), show.legend = FALSE) +
    geom_edge_label(size = 4, colour = "red", fontface = "bold") +
    geom_node_label(line_list = list(aes(label = paste0("Node ", id, ": ", splitvar)),
                aes(label = paste0("N=", node.size[id], ", p", 
                                 ifelse(pvals < .001, "<.001",
                                        paste0("=", round(pvals, 3)))), 
                    size = 9)),
                    line_gpar = list(list(size = 12), 
                                     list(size = 11)),
                ids = "inner", fontface = "bold", size = 12) +
    geom_node_info() +
    geom_node_label(aes(label = paste0("N = ", node.size), fontface = "bold"),
                    ids = "terminal", nudge_y = -0.0, nudge_x = 0.01) +
    geom_node_plot(gglist = list(
        geom_bar(aes(x = "", fill = species), size = 0.2, width = 0.9,
                 position = position_fill(), color = "black"),
        theme_minimal(base_family = "arial", base_size = 14),
        scale_fill_manual(values = c("gray50","gray55","gray60",
                                     "gray70","gray80","gray85",
                                     "blue","gray95")),
        xlab(""), 
        ylab("Probability"), 
        geom_text(aes(x = "", group = species, 
                      label = stat(count)),
                  stat = "count", position = position_fill(), 
                  vjust = 1.)),
        shared_axis_labels = TRUE, size = 1.25)
```

```{r}
library(rpart.plot)

rpart.rules(chaid_tree)
```


A printing version in TIFF format could be:
```{r grh_print, eval=FALSE}
# tiff(filename = "~/home/chaid_tree.tiff",
#      width = 3000, height = 1800, units = "px", pointsize = 1,
#      compression = "lzw", bg = "white", res = 600)
# 
# ggparty(chaid_tree) +
#     geom_edge(aes(color = id), show.legend = FALSE) +
#     geom_edge_label(size = 1, colour = "red", fontface = "bold") +
#     geom_node_label(line_list = list(aes(label = paste0("Node ", id,": ", splitvar)),
#                             aes(label = paste0("N=", node.size[id], ", p",
#                                 ifelse(pvals < .001, "<.001",
#                                      paste0("=", round(pvals, 3)))))),
#                     line_gpar = list(list(size = 4), 
#                                      list(size = 4)),
#                     ids = "inner", label.size = 0.1) +
#     geom_node_info(size = 2) +
#     geom_node_label(aes(label = paste0("N = ", nodesize)),
#                     ids = "terminal", nudge_y = -0.0, 
#                     nudge_x = 0.01, label.size = 0.1,
#                     line_gpar = list(list(size = 3.5), 
#                                      list(size = 3.5))) +
#     geom_node_plot(gglist = list(
#         geom_bar(aes(x = "", fill = species), size = 0.2, width = 10,
#                  position = position_fill(), color = "black"),
#         theme_minimal(base_family = "arial", base_size = 5),
#         scale_fill_manual(values = c("gray50","gray55","gray60",
#                                      "gray70","gray80","gray85",
#                                      "blue","gray95")),
#         xlab(""), 
#         ylab("Probability"), 
#         geom_text(aes(x = "", group = species, 
#                       label = stat(count)),
#                   stat = "count", position = position_fill(), 
#                   vjust = 1., size = 1)),
#         shared_axis_labels = TRUE, size = 1.)
# 
# 
# dev.off()

```



# References
 1.<a name="1"></a> Sanchez R, Morgado E, Grau R. Gene algebra from a genetic
 code algebraic structure. J Math Biol. 2005 Oct;51(4):431-57. doi:
 10.1007/s00285-005-0332-8. Epub 2005 Jul 13. PMID: 16012800. (
 [PDF](https://arxiv.org/pdf/q-bio/0412033.pdf)).
 
 2.<a name="2"></a> Robersy Sanchez, Jesús Barreto (2021) Genomic Abelian Finite
  Groups.
 [doi: 10.1101/2021.06.01.446543](https://doi.org/10.1101/2021.06.01.446543).
 
 3.<a name="3"></a> M. V José, E.R. Morgado, R. Sánchez, T. Govezensky, The 24
 possible algebraic representations of the standard genetic code in six or in
 three dimensions, Adv. Stud. Biol. 4 (2012)
 119–152.[PDF](https://is.gd/na9eap).
 
 4.<a name="4"></a> R. Sanchez. Symmetric Group of the Genetic–Code Cubes.
 Effect of the Genetic–Code Architecture on the Evolutionary Process MATCH
 Commun. Math. Comput. Chem. 79 (2018) 527-560. [PDF](https://bit.ly/2Z9mjM7).

